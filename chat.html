<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" type="image/x-icon" href="favicon.png" />
<title>Private Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
:root { --bg1:#071428; --bg2:#041022; --muted:#9aa8bb; --accent:#4f46e5; }
*{box-sizing:border-box}
body{margin:0;height:100vh;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto}
.header{display:flex;align-items:center;gap:12px;padding:14px;background:rgba(255,255,255,0.02)}
.back{background:transparent;border:none;color:#9bd;cursor:pointer;font-size:18px}
.otherPic{width:40px;height:40px;border-radius:10px;object-fit:cover;background:#0b1220}
.msg{max-width:60%; width: fit-content; padding:10px;border-radius:12px;background:rgba(255,255,255,0.04);position:relative;word-break:break-word}
.msg.me{align-self:flex-end;background:linear-gradient(90deg,#090909,#070707);color:#fff}
.meta{font-size:12px;color:var(--muted);margin-bottom:6px;display:block}
.compose{display:flex;padding:12px;gap:8px;background:rgba(0,0,0,0.04);align-items:flex-end}
.input{flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:#fff;min-height:42px;resize:none;overflow:hidden;margin-bottom:1rem}
.send{border:none;background:transparent;color:#fff;cursor:pointer;padding:6px;display:flex;align-items:center;justify-content:center}
.replyBar { display:flex; flex-direction:row; align-items:center; border-left:4px solid var(--accent); padding:6px 10px; margin:8px 12px 4px 12px; background:rgba(255,255,255,0.03); border-radius:8px; }
.replyBarText { flex:1; font-size:14px; color:#d1d5db; }
.cancelReplyBtn { cursor:pointer; padding:6px 10px; color:#ff6b6b; font-weight:600; }
.replyBubble { border-left:4px solid rgba(255,255,255,0.12); padding-left:8px; margin-bottom:6px; opacity:0.95; font-size:13px; }
#loadingOverlay { position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);color:#fff;display:flex;align-items:center;justify-content:center;font-size:18px;z-index:9999; display:none;}
.ctxMenu{position:fixed;background:#071428;border:1px solid rgba(255,255,255,0.06);box-shadow:0 6px 20px rgba(0,0,0,0.6);padding:6px;border-radius:8px;z-index:10000}
.ctxBtn{padding:8px 12px;cursor:pointer;border-radius:6px;font-size:14px;color:#d1d5db;white-space:nowrap}
.ctxBtn:hover{background:rgba(255,255,255,0.03)}
.ctxBtn.delete{color:#ff6b6b}
.ctxBtn.reply{color:var(--accent);font-weight:600}
.smallNote{font-size:12px;color:var(--muted);padding:8px 12px}

/* image bubble */
.msg img.chat-image{ display:block; max-width:100%; height:auto; border-radius:10px; cursor:pointer; }

/* attach button styling (left of input) */
.attachBtn{
  width:40px;height:40px;border-radius:10px;border:none;background:rgba(255,255,255,0.02);
  display:flex;align-items:center;justify-content:center;cursor:pointer;color:#fff;font-size:20px;
}
.compose { align-items:flex-end; }

/* viewer modal */
#imgViewer {
  position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);z-index:20000;padding:12px;
}
#imgViewer img{ max-width:100%; max-height:100%; object-fit:contain; transition: transform 0.18s ease; cursor: grab; }
#imgViewer .closeBtn{ position:absolute; top:14px; right:14px; background:rgba(255,255,255,0.06); color:#fff; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
#imgViewer .downloadBtn{ position:absolute; top:14px; left:14px; background:rgba(255,255,255,0.06); color:#fff; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:700; }

/* responsive tweaks */
@media (max-width:600px){  .attachBtn{ width:36px;height:36px; } .send svg{ width:24px;height:24px } }

.container {
  display: flex;
  flex-direction: column;
  height: calc(100dvh - 64px);
}
.messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}


/* scroll barr?? */

/* ---------------- CHAT SCROLLBAR ---------------- */
/* WhatsApp-style thin scrollbar for chat sections */
.container {
  overflow-y: auto;
  scroll-behavior: smooth;
  scrollbar-width: thin;          /* Firefox */
  scrollbar-color: rgba(255,255,255,0.3) transparent;
}

/* Chrome, Edge, Safari */
.container ::-webkit-scrollbar {
  width: 6px;       /* thin scrollbar */
}

.container::-webkit-scrollbar-track {
  background: transparent;  /* track invisible */
}

.container::-webkit-scrollbar-thumb {
  background-color: rgba(255,255,255,0.3); /* thumb color */
  border-radius: 3px;                       /* rounded corners */
  border: 1px solid transparent;            /* keeps it slim */
}

.container::-webkit-scrollbar-thumb:hover {
  background-color: rgba(255,255,255,0.5); /* hover highlight */
}

/* small visual for longpress */
  .msg.longpressing { outline:2px solid rgba(255,255,255,0.04); transform:scale(0.998); }

  @media (max-width:600px){ .msg{max-width:90%} .replyText{max-width:160px} }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
  ::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }

  /* Hide default page scrollbar */
html, body {
  margin: 0;
  height: 100vh;
  overflow: hidden;  /* prevents page scrolling */
}

/* Ensure chat container scrolls */
.container {
  flex: 1;                  /* fills remaining height */
  display: flex;
  flex-direction: column;
  overflow-y: auto;         /* only container scrolls */
  scroll-behavior: smooth;
}


</style>
</head>
<body>

<div id="loadingOverlay">Loading...</div>
<div id="replyPreviewHolder"></div>

<div class="header">
  <button class="back" onclick="location.href='members.html'">‚Üê</button>
  <img id="otherPic" class="otherPic" src="https://via.placeholder.com/80x80?text=?" alt="." />
  <div>
    <div id="otherName" style="font-weight:700">Chat</div>
    <div id="otherStatus" style="font-size:12px;color:#9aa8bb">Connecting...</div>
  </div>
</div>

<div class="container">
  <div class="messages" id="messages" tabindex="0" aria-live="polite"></div>

  <div class="compose" aria-label="Message composer">
    <!-- Attach button (left) + hidden file input -->
    <button id="btnAttach" class="attachBtn" title="Attach image">Ôºã</button>
    <input id="filePicker" type="file" accept="image/*" style="display:none" />
    <textarea id="text" class="input" placeholder="Type a message..." rows="1" aria-label="Message input"></textarea>
    <button id="btnSend" class="send" title="Send (Enter)">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M9.61109 12.4L10.8183 18.5355C11.0462 19.6939 12.6026 19.9244 13.1565 18.8818L19.0211 7.84263C19.248 7.41555 19.2006 6.94354 18.9737 6.58417M9.61109 12.4L5.22642 8.15534C4.41653 7.37131 4.97155 6 6.09877 6H17.9135C18.3758 6 18.7568 6.24061 18.9737 6.58417M9.61109 12.4L18.9737 6.58417M19.0555 6.53333L18.9737 6.58417" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
      </svg>
    </button>
  </div>
</div>

<!-- Image viewer modal -->
<div id="imgViewer" role="dialog" aria-hidden="true">
  <button class="closeBtn" id="viewerClose">Close</button>
  <a id="viewerDownload" class="downloadBtn" download>Download</a>
  <img id="viewerImage" src="" alt="Image preview" />
</div>

<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>

<script>
/* ---------------- FIREBASE CONFIG ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyBdhQFVF0PTZMw0DXT5zBLpxndw_HNSv5U",
  authDomain: "gatochat-56ab6.firebaseapp.com",
  databaseURL: "https://gatochat-56ab6-default-rtdb.firebaseio.com",
  projectId: "gatochat-56ab6",
  storageBucket: "gatochat-56ab6.firebasestorage.app",
  messagingSenderId: "888124564246",
  appId: "1:888124564246:web:33a41ee68eec0f6b9c2637"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

/* ---------------- IMG UPLOAD CONFIG ---------------- */
/* Replace the string below with your ImgBB API key, e.g.
   const IMGBB_KEY = "0370e1f4c1a7bfcc9xxxxxxxxxxxxxxx";
*/
const IMGBB_KEY = "9de61cf69da55fffd9fc05998c9acadd"; // <-- PUT YOUR IMGBB KEY HERE

/* ---------------- PAGE STATE ---------------- */
const chatId = new URLSearchParams(location.search).get("chatId");
const other = new URLSearchParams(location.search).get("other");
if(!chatId || !other){ location.href = "members.html"; }

let replyTarget = null, otherName = "User";
const imageCache = {}; // runtime cache for Image objects
const localImageCacheKey = "chat_image_cache_v1"; // localStorage key (stores map url->true)
const BATCH_SIZE = 30;
let oldestLoadedTime = null, loadingHistory = false;

/* ---------------- LOADING UI ---------------- */
const loadingEl = document.getElementById("loadingOverlay");
function showLoading(text="Loading..."){ loadingEl.style.display="flex"; loadingEl.textContent=text; }
function hideLoading(){ loadingEl.style.display="none"; }

/* ---------------- UTIL ---------------- */
function escapeHtml(x){ return String(x||'').replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
function scrollToBottom(){ const el=document.getElementById("messages"); el.scrollTop = el.scrollHeight; }
function preloadImage(url){ if(!url) return; if(imageCache[url]) return; const img=new Image(); img.src=url; imageCache[url]=img; try{ // cache mark locally
  const lc = JSON.parse(localStorage.getItem(localImageCacheKey) || "{}"); lc[url] = true; localStorage.setItem(localImageCacheKey, JSON.stringify(lc));
}catch(e){} }

/* ---------------- AUTH + INIT ---------------- */
auth.onAuthStateChanged(u=>{
  if(!u) location.href="login.html";
  else { initPresence(u); initChat(u); initAttach(u); }
});

/* ---------------- chat init ---------------- */
function initChat(user){
  const messagesEl=document.getElementById("messages");
  const nameEl=document.getElementById("otherName");
  const statusEl=document.getElementById("otherStatus");
  const otherPicEl=document.getElementById("otherPic");

  const cachedPhoto = localStorage.getItem("photo_" + other);
  if(cachedPhoto) otherPicEl.src = cachedPhoto;

  db.ref("users/"+other).on("value",s=>{
    const val = s.val()||{};
    otherName = val.name||"User";
    nameEl.innerText = otherName;
    const photoUrl = val.photo || "https://via.placeholder.com/80x80?text=?";
    otherPicEl.src = photoUrl;
    preloadImage(photoUrl);
    try{ localStorage.setItem("photo_" + other, photoUrl); }catch(e){}
  });

  db.ref("presence/"+other).on("value",snap=>{
    const p=snap.val();
    statusEl.innerText = p?.online ? "Online" : "Last seen: " + new Date(p?.lastSeen||Date.now()).toLocaleString();
  });

  const rendered = new Set();
  const msgRef = db.ref(`privateChats/${chatId}/messages`);

  // Load latest messages
  showLoading("Loading messages...");
  msgRef.orderByChild("time").limitToLast(BATCH_SIZE).once("value").then(snap=>{
    messagesEl.innerHTML = "";
    const msgs = [];
    snap.forEach(c=>{ const d=c.val(); d.id=c.key; msgs.push(d); });
    msgs.forEach(m=>{ renderMsg(m, user.uid); markAsSeen(m.id, user.uid); rendered.add(m.id); });
    if(msgs.length) oldestLoadedTime = msgs[0].time;
    setTimeout(()=>{ scrollToBottom(); hideLoading(); },50);
  }).catch(err=>{ console.error(err); hideLoading(); });

  // Infinite scroll load older
  messagesEl.addEventListener("scroll", async function(){
    if(this.scrollTop <= 0 && !loadingHistory && oldestLoadedTime){
      loadingHistory = true; showLoading("Loading older messages...");
      try{
        const snap = await msgRef.orderByChild("time").endAt(oldestLoadedTime - 1).limitToLast(BATCH_SIZE).once("value");
        const msgs = []; snap.forEach(c=>{ const d=c.val(); d.id=c.key; msgs.push(d); });
        if(msgs.length===0){ oldestLoadedTime = null; loadingHistory=false; hideLoading(); return; }
        const scrollBefore = messagesEl.scrollHeight;
        msgs.forEach(m => renderMsgAtTop(m, user.uid));
        oldestLoadedTime = msgs[0].time;
        const scrollAfter = messagesEl.scrollHeight;
        messagesEl.scrollTop = scrollAfter - scrollBefore;
      }catch(e){ console.error(e); }
      finally{ loadingHistory=false; hideLoading(); }
    }
  });

  // Live new messages
  const startAtTime = Date.now();
  msgRef.orderByChild("time").startAt(startAtTime).on("child_added", snap=>{
    const m = snap.val(); m.id = snap.key;
    if(!rendered.has(m.id)){
      renderMsg(m, user.uid);
      markAsSeen(m.id, user.uid);
      rendered.add(m.id);
      scrollToBottom();
    }
  });

  // changes (ticks etc)
  msgRef.on("child_changed", snap=>{
    const m = snap.val(); m.id = snap.key;
    const el = document.querySelector(`[data-msgid="${m.id}"]`);
    if(el) updateMsgTicks(el,m,user.uid);
  });

  // deletions
  msgRef.on("child_removed", snap=>{
    const el = document.querySelector(`[data-msgid="${snap.key}"]`);
    if(el) el.innerHTML = `<div class="smallNote">Message deleted</div>`;
    // Remove from local cache if stored
    try{
      const lc = JSON.parse(localStorage.getItem(localImageCacheKey) || "{}");
      // unknown URL; iterate and remove any matching firebase msg? We store only url->true so nothing to remove specifically here
      localStorage.setItem(localImageCacheKey, JSON.stringify(lc));
    }catch(e){}
  });

  // send handlers
  const input = document.getElementById("text");
  document.getElementById("btnSend").onclick = ()=> sendMessage(user);
  input.addEventListener("keydown",(e)=>{ if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); sendMessage(user); } });
  // auto-resize textarea
  const autoResize = ()=>{ input.style.height='auto'; input.style.height = Math.min(200, input.scrollHeight) + 'px'; };
  input.addEventListener('input', autoResize);
  autoResize();
}

/* ================= SEND MESSAGE (text) ================= */
function sendMessage(user){
  const elText = document.getElementById("text");
  const text = elText.value.trim();
  if(!text) return;
  const newMsg = { sender: user.uid, senderName: user.displayName||"You", text: text, time: Date.now(), seenBy: [user.uid], type: "text" };
  if(replyTarget) newMsg.reply = { id: replyTarget.id, sender: replyTarget.sender, senderName: replyTarget.senderName, text: replyTarget.text };
  db.ref(`privateChats/${chatId}/messages`).push(newMsg).catch(err=>console.error("send error", err));
  elText.value = ""; elText.style.height='auto';
  hideReplyPreview();
  scrollToBottom();
}

/* ================= IMAGE UPLOAD & SEND ================= */
function initAttach(user){
  const attachBtn = document.getElementById("btnAttach");
  const filePicker = document.getElementById("filePicker");

  attachBtn.addEventListener("click", ()=> filePicker.click());
  filePicker.addEventListener("change", async (e)=>{
    const f = e.target.files[0];
    filePicker.value = "";
    if(!f) return;
    if(!f.type.startsWith("image/")) return alert("Please choose an image.");
    try{
      // optional resize/compress if file too large ( > 1.6MB )
      const fileToUpload = await maybeResizeImageFile(f, 1600 * 1024);
      await uploadAndSendImage(fileToUpload, user);
    }catch(err){
      console.error("Image send failed", err);
      alert("Failed to send image.");
    }
  });
}

/* Resize/compress using canvas if needed. Returns File or Blob */
function maybeResizeImageFile(file, maxBytes){
  return new Promise(resolve=>{
    if(file.size <= maxBytes) return resolve(file);
    const img = new Image();
    const reader = new FileReader();
    reader.onload = ()=> { img.src = reader.result; };
    img.onload = ()=>{
      // downscale proportionally
      const canvas = document.createElement("canvas");
      const maxDim = Math.max(img.width, img.height);
      const scale = Math.max(1, maxDim / 1600);
      canvas.width = Math.round(img.width / scale);
      canvas.height = Math.round(img.height / scale);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      canvas.toBlob(blob => {
        if(blob) resolve(new File([blob], file.name, { type: blob.type }));
        else resolve(file);
      }, 'image/jpeg', 0.8);
    };
    reader.readAsDataURL(file);
  });
}

async function uploadAndSendImage(file, user){
  showLoading("Uploading image...");
  try{
    const url = await uploadToImgBB(file);
    if(!url) throw new Error("Upload failed");
    // push image message
  const newMsg = {
  sender: user.uid,
  senderName: user.displayName || "You",
  time: Date.now(),
  seenBy: [user.uid],
  type: "image",
  url: url,
  fileName: file.name  // üî• FIX: store image filename
};

if (replyTarget) {
  newMsg.reply = {
    id: replyTarget.id,
    sender: replyTarget.sender,
    senderName: replyTarget.senderName,
    text: replyTarget.text
  };
}

    if(replyTarget) newMsg.reply = { id: replyTarget.id, sender: replyTarget.sender, senderName: replyTarget.senderName, text: replyTarget.text };
    await db.ref(`privateChats/${chatId}/messages`).push(newMsg);
    preloadImage(url);
    hideReplyPreview();
    scrollToBottom();
  }catch(e){
    console.error(e);
    alert("Image upload failed.");
  }finally{
    hideLoading();
  }
}

/* Upload to ImgBB using FormData (expects you to fill IMGBB_KEY) */
async function uploadToImgBB(fileOrBlob){
  if(!IMGBB_KEY || IMGBB_KEY === "REPLACE_WITH_IMGBB_KEY"){
    alert("ImgBB API key not set. Add your key to the script.");
    throw new Error("No IMGBB key");
  }
  const form = new FormData();
  form.append("image", fileOrBlob);
  const res = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_KEY}`, {
    method: "POST",
    body: form
  });
  const json = await res.json();
  if(json && json.data && json.data.url) return json.data.url;
  console.error("ImgBB response:", json);
  return null;
}



/* ================= RENDER MESSAGE ================= */
function renderMsg(m, my){
  const box = document.createElement("div");
  box.className = "msg" + (m.sender===my ? " me" : "");
  box.dataset.msgid = m.id;

  let replyHtml = "";
  if(m.reply){
    replyHtml = `<div class="replyBubble"><div style="font-weight:600;">${m.reply.sender===my ? "You" : (escapeHtml(m.reply.senderName || otherName))}</div><div style="opacity:0.8;">${escapeHtml(m.reply.text)}</div></div>`;
  }

  const senderName = m.sender===my ? "You" : escapeHtml(m.senderName || otherName);
  const ticks = getTicks(m,my);

  // render by type
  let contentHtml = "";
  if(m.type === "image" && m.url){
    const safeUrl = escapeHtml(m.url);
    contentHtml = `<div><img class="chat-image" src="${safeUrl}" alt="image" loading="lazy" /></div>`;
    // prefetch/cache
    preloadImage(m.url);
  } else {
    contentHtml = `<div>${escapeHtml(m.text)}</div>`;
  }

  box.innerHTML = `<div class="meta">${senderName} ‚Ä¢ ${new Date(m.time).toLocaleTimeString()} ${ticks}</div>${replyHtml}${contentHtml}`;
  enableMessageContext(box,m);

  // image click ‚Üí viewer
  const imgEl = box.querySelector("img.chat-image");
  if(imgEl){
    imgEl.addEventListener("click", ()=> openImageViewer(m.url));
  }

  document.getElementById("messages").appendChild(box);
}

function renderMsgAtTop(m,my){
  const box = document.createElement("div");
  box.className = "msg" + (m.sender===my ? " me" : "");
  box.dataset.msgid = m.id;

  let replyHtml = "";
  if(m.reply){
    replyHtml = `<div class="replyBubble"><div style="font-weight:600;">${m.reply.sender===my ? "You" : (escapeHtml(m.reply.senderName || otherName))}</div><div style="opacity:0.8;">${escapeHtml(m.reply.text)}</div></div>`;
  }

  const senderName = m.sender===my ? "You" : escapeHtml(m.senderName || otherName);
  const ticks = getTicks(m,my);

  let contentHtml = "";
  if(m.type === "image" && m.url){
    const safeUrl = escapeHtml(m.url);
    contentHtml = `<div><img class="chat-image" src="${safeUrl}" alt="image" loading="lazy" /></div>`;
    preloadImage(m.url);
  } else {
    contentHtml = `<div>${escapeHtml(m.text)}</div>`;
  }

  box.innerHTML = `<div class="meta">${senderName} ‚Ä¢ ${new Date(m.time).toLocaleTimeString()} ${ticks}</div>${replyHtml}${contentHtml}`;
  enableMessageContext(box,m);

  const imgEl = box.querySelector("img.chat-image");
  if(imgEl){
    imgEl.addEventListener("click", ()=> openImageViewer(m.url));
  }

  const messagesEl = document.getElementById("messages");
  messagesEl.insertBefore(box, messagesEl.firstChild);
}

/* ================= TICKS ================= */
function getTicks(m,my){ if(!m) return ""; return (m.sender !== my) ? "" : (m.seenBy && Array.isArray(m.seenBy) && m.seenBy.includes(other) ? "‚úî‚úî" : "‚úî"); }
function updateMsgTicks(el,m,my){ const meta = el.querySelector(".meta"); if(meta){ meta.innerText = `${m.sender===my ? "You" : (m.senderName || otherName)} ‚Ä¢ ${new Date(m.time).toLocaleTimeString()} ${getTicks(m,my)}`; } }

/* ================= LONG PRESS / CONTEXT MENU ================= */
let activeMenu = null;
function enableMessageContext(el,msg){
  let timer = null;
  el.addEventListener("contextmenu", e=>{
    e.preventDefault();
    showMenu(e.clientX, e.clientY, msg);
  });
  el.addEventListener("touchstart", e=>{
    const t = e.touches[0];
    timer = setTimeout(()=> showMenu(t.clientX, t.clientY, msg), 600);
  });
  ["touchend","touchmove","touchcancel"].forEach(ev=>el.addEventListener(ev, ()=>{ if(timer) clearTimeout(timer); timer=null; }));
}
function showMenu(x,y,msg){
  hideMenu();
  const menu = document.createElement("div");
  menu.className = "ctxMenu";
  menu.style.left = Math.max(8, x) + "px";
  menu.style.top = Math.max(8, y) + "px";

  const btnReply = document.createElement("div");
  btnReply.className = "ctxBtn reply";
  btnReply.innerText = "Reply";
  btnReply.onclick = ()=>{ hideMenu(); showReplyPreview(msg); };

  const btnDelete = document.createElement("div");
  btnDelete.className = "ctxBtn delete";
  btnDelete.innerText = "Delete";
  btnDelete.onclick = ()=>{ hideMenu(); if(confirm("Delete this message?")) {
    // Unsend: remove message node (image entry removed too)
    db.ref(`privateChats/${chatId}/messages/${msg.id}`).remove().then(()=>{
      // also remove from local cache mark (best-effort)
      try{
        const lc = JSON.parse(localStorage.getItem(localImageCacheKey) || "{}");
        if(msg && msg.url) { delete lc[msg.url]; localStorage.setItem(localImageCacheKey, JSON.stringify(lc)); }
      }catch(e){}
    }).catch(err=>console.error(err));
  } };

  const btnCancel = document.createElement("div");
  btnCancel.className = "ctxBtn cancel";
  btnCancel.innerText = "Cancel";
  btnCancel.onclick = hideMenu;

  menu.appendChild(btnReply);
  menu.appendChild(btnDelete);
  menu.appendChild(btnCancel);

  document.body.appendChild(menu);
  activeMenu = menu;
  setTimeout(()=> window.addEventListener("click", hideMenu), 0);
}
function hideMenu(){ if(activeMenu){ activeMenu.remove(); activeMenu=null; window.removeEventListener("click", hideMenu); } }

/* ================= REPLY PREVIEW ================= */
function showReplyPreview(msg){
    document.getElementById("text").focus();

  let previewText = "";

if (msg.type === "text") {
  previewText = msg.text;
} else if (msg.type === "image") {
  previewText = msg.fileName 
    ? "[Image] " + msg.fileName 
    : "[Image]";
}

replyTarget = {
  id: msg.id,
  sender: msg.sender,
  senderName: msg.senderName || otherName,
  text: previewText
};

  const holder = document.getElementById("replyPreviewHolder");
  const youOrName = (typeof auth.currentUser !== 'undefined' && auth.currentUser && replyTarget.sender === auth.currentUser.uid) ? "You" : escapeHtml(replyTarget.senderName);
  holder.innerHTML = `<div class="replyBar"><div class="replyBarText"><div style="font-weight:600;">Replying to ${youOrName}</div><div style="opacity:0.8;">${escapeHtml(replyTarget.text)}</div></div><div class="cancelReplyBtn" onclick="hideReplyPreview()">‚úï</div></div>`;
}
function hideReplyPreview(){ replyTarget = null; document.getElementById("replyPreviewHolder").innerHTML = ""; }

/* ================= PRESENCE (stable) ================= */
function initPresence(user){
  if(!user || !user.uid) return;
  const uid = user.uid;
  const presenceRef = db.ref("presence/"+uid);
  const connectedRef = db.ref(".info/connected");
  connectedRef.on("value", snap=>{
    if(snap.val() === true){
      // mark online (no continuous lastSeen updates)
      presenceRef.update({ online: true, name: user.displayName || "" }).catch(()=>{});
      // onDisconnect set offline + server timestamp
      presenceRef.onDisconnect().set({ online: false, lastSeen: firebase.database.ServerValue.TIMESTAMP, name: user.displayName || "" }).catch(()=>{});
    }
  });
}

/* ================= MARK AS SEEN ================= */
function markAsSeen(msgId, userId){
  if(!msgId) return;
  const seenRef = db.ref(`privateChats/${chatId}/messages/${msgId}/seenBy`);
  seenRef.once("value").then(snap=>{
    const arr = snap.val() || [];
    if(!Array.isArray(arr)){
      const coerced = Array.isArray(arr) ? arr : Object.values(arr || {});
      if(!coerced.includes(userId)){ coerced.push(userId); seenRef.set(coerced); }
    } else {
      if(!arr.includes(userId)){ arr.push(userId); seenRef.set(arr); }
    }
  }).catch(e=>console.error("seen error",e));
}

/* ================= IMAGE VIEWER (fullscreen) ================= */
const viewer = document.getElementById("imgViewer");
const viewerImg = document.getElementById("viewerImage");
const viewerClose = document.getElementById("viewerClose");
const viewerDownload = document.getElementById("viewerDownload");
let viewerScale = 1;
let isPanning = false;
let startX=0, startY=0, currentTranslateX=0, currentTranslateY=0;

function openImageViewer(url){
  if(!url) return;
  viewer.style.display = "flex";
  viewer.setAttribute("aria-hidden", "false");
  viewerImg.src = url;
  viewerImg.style.transform = "translate(0px,0px) scale(1)";
  viewerScale = 1; currentTranslateX=0; currentTranslateY=0;
  viewerDownload.href = url;
  viewerDownload.setAttribute('download','image');
  // prevent background scroll
  document.body.style.overflow = "hidden";
}

// close
function closeImageViewer(){
  viewer.style.display = "none";
  viewer.setAttribute("aria-hidden", "true");
  viewerImg.src = "";
  document.body.style.overflow = "";
}

// simple zoom toggle on double-click/double-tap
viewerImg.addEventListener("dblclick", ()=>{
  viewerScale = (viewerScale === 1 ? 2 : 1);
  viewerImg.style.transform = `translate(${currentTranslateX}px,${currentTranslateY}px) scale(${viewerScale})`;
});

// pointer events for panning when zoomed
viewerImg.addEventListener("pointerdown", (e)=>{
  if(viewerScale <= 1) return;
  isPanning = true; startX = e.clientX; startY = e.clientY;
  viewerImg.setPointerCapture(e.pointerId);
});
viewerImg.addEventListener("pointermove", (e)=>{
  if(!isPanning) return;
  const dx = e.clientX - startX; const dy = e.clientY - startY;
  currentTranslateX += dx; currentTranslateY += dy;
  startX = e.clientX; startY = e.clientY;
  viewerImg.style.transform = `translate(${currentTranslateX}px,${currentTranslateY}px) scale(${viewerScale})`;
});
viewerImg.addEventListener("pointerup", (e)=>{ isPanning=false; try{ viewerImg.releasePointerCapture(e.pointerId);}catch(e){} });
viewerImg.addEventListener("pointercancel", ()=> isPanning=false);

viewerClose.addEventListener("click", closeImageViewer);
viewer.addEventListener("click", e=>{ if(e.target === viewer) closeImageViewer(); });

/* ================= MOBILE INPUT FIX FOR KEYBOARD (keeps compose visible) ================= */
const compose = document.querySelector(".compose");
if (window.visualViewport) {
  const updateBar = () => {
    const viewport = window.visualViewport;
    const bottomOffset = window.innerHeight - viewport.height - viewport.offsetTop;
    compose.style.bottom = (bottomOffset > 0 ? bottomOffset + "px" : "0px");
  };
  window.visualViewport.addEventListener("resize", updateBar);
  window.visualViewport.addEventListener("scroll", updateBar);
}

/* ================= INITIAL LOCAL CACHING SETUP ================= */
try{
  const lc = JSON.parse(localStorage.getItem(localImageCacheKey) || "{}");
  Object.keys(lc).forEach(url => preloadImage(url));
}catch(e){}

/* ================= scroll screen when upload image ================= */
function addMessageToChat(msg) {
    const box = document.querySelector(".messages");

    const wrap = document.createElement("div");
    wrap.className = "msg " + (msg.uid === auth.currentUser.uid ? "me" : "");

    // image?
    if (msg.imageUrl) {
        const img = document.createElement("img");
        img.src = msg.imageUrl;
        img.className = "chat-image";
        wrap.appendChild(img);

        img.onload = () => scrollToBottom();  // FIX for image scroll
    } 
    
    // text?
    if (msg.text) {
        wrap.appendChild(document.createTextNode(msg.text));
    }

    box.appendChild(wrap);

    scrollToBottom();  // fallback
}


</script>

</body>
</html>



